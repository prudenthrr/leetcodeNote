# 剑指Offer

### 1.青蛙的n级跳

**题目描述：**

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

**解题思路：**

1）这里的f(n) 代表的是n个台阶有一次1,2,...n阶的 跳法数。

2）n = 1时，只有1种跳法，f(1) = 1

3) n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2) 

4) n = 3时，会有三种跳得方式，1阶、2阶、3阶，

    那么就是第一次跳出1阶后面剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3)
    因此结论是f(3) = f(3-1)+f(3-2)+f(3-3)

5) n = n时，会有n中跳的方式，1阶、2阶...n阶，得出结论：

    f(n) = f(n-1)+f(n-2)+...+f(n-(n-1)) + f(n-n) => f(0) + f(1) + f(2) + f(3) + ... + f(n-1）

6) 由以上已经是一种结论，但是为了简单，我们可以继续简化：

    f(n-1) = f(0) + f(1)+f(2)+f(3) + ... + f((n-1)-1) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2)
    f(n) = f(0) + f(1) + f(2) + f(3) + ... + f(n-2) + f(n-1) = f(n-1) + f(n-1)
    
    可以得出：f(n) = 2*f(n-1)
**代码实现**

```python
# -*- coding:utf-8 -*-
class Solution:
    def jumpFloorII(self, number):
        # write code here
        if number==1:
            return 1
        res = 1
        for i in range(2,number+1):
            res = 2 * res
        return res
```

### 2.2  *1的小矩形覆盖一个2 *n的大矩形，总共有多少种方法？

题目描述：

我们可以用2  *1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2  *1的小矩形无重叠地覆盖一个2 *n的大矩形，总共有多少种方法？

**解题思路：**

和爬楼梯一样， f(n) = F(n-1)+f(n-2)

### 3.二进制表示中1的个数

**题目描述：**

输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

**解题思路：**

首先判断n是不是负数，当n为负数的时候，直接用后面的while循环会导致死循环，因为负数向左移位的话最高位补1 ！ 因此需要一点点特殊操作，可以将最高位的符号位1变成0，也就是n & 0x7FFFFFFF，这样就把负数转化成正数了，唯一差别就是最高位由1变成0，因为少了一个1，所以count加1。如果是正数那么直接按位与，然后右移一位再继续跟1按位与就可以得到1的个数。
```python
# -*- coding:utf-8 -*-
class Solution:
    def NumberOf1(self, n):
        # write code here
        res = 0
        if n<0:
            n = n & 0x7FFFFFFF
            res = res + 1   #这里为了节省时间可以使用 + +count
        while n != 0:
            res += n & 1
            n = n >> 1
        return res
```

### 4.奇数位于数组的前半部分，所有的偶数位于数组的后半部分。

**题目描述：**

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

**解题思路：**

使用python内部的filter()方法

```python
# -*- coding:utf-8 -*-
class Solution:
    def reOrderArray(self, array):
        # write code here
        odd_list = filter(lambda x:x%2!=0, array)
        evev_list = filter(lambda x:x%2==0, array)
        return list(odd_list) + list(evev_list)
```

### 5.输入一个链表，输出该链表中倒数第k个结点。

```python
class Solution:
    def FindKthToTail(self, head, k):
        # write code here
        if head is None:
            return head
        dic = {}
        c = 1
        ptr = head
        while ptr:
            dic[c] = ptr
            ptr = ptr.next
            c += 1
        n = len(dic)-k+1
        if n in dic:
            return dic[n]
        else:
            return None
```

### 6.反转链表

```python
# -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    # 返回ListNode
    def ReverseList(self, pHead):
        # write code here
        if pHead is None or pHead.next is None:
            return pHead
        pre, ptr = pHead, pHead.next
        pre.next = None    # 注意这句
        while ptr:
            tmp = ptr.next
            ptr.next = pre
            pre = ptr
            ptr = tmp
        return pre
```

### 7.输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

```python
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def HasSubtree(self, pRoot1, pRoot2):
        # write code here
        if pRoot1 is None or pRoot2 is None:
            return False
        result = False
        if pRoot1.val == pRoot2.val:
            result = self.isSubset(pRoot1, pRoot2)
        if not result:
            result = self.HasSubtree(pRoot1.left, pRoot2) or self.HasSubtree(pRoot1.right, pRoot2)
        return result

    def isSubset(self,root1,root2):
        if root2 is None:
            return True
        if root1 is None:
            return False
        if root1.val==root2.val:
            return self.isSubset(root1.left, root2.left) and self.isSubset(root1.right, root2.right)
        return False
```

### 8.输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树

```python
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 返回构造的TreeNode根节点
    def reConstructBinaryTree(self, pre, tin):
        # write code here
        if len(pre)==0 or len(tin)==0:
            return None
        root = TreeNode(pre[0])
        for order, item in enumerate(tin):
            if root.val==item:
                root.left = self.reConstructBinaryTree(pre[1:order+1], tin[:order])
                root.right = self.reConstructBinaryTree(pre[order+1:], tin[order+1:])
                return root
```

### 9.交换二叉树的左右孩子（源二叉树的镜像）

```python
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    # 返回镜像树的根节点
    def Mirror(self, root):
        # write code here
        if root is None:
            return root
        left = self.Mirror(root.left)
        right = self.Mirror(root.right)
        root.left = right
        root.right = left
        return root
```

### 10.按顺时针遍历二维数组

```python
# -*- coding:utf-8 -*-
class Solution:
    # matrix类型为二维列表，需要返回列表
    def printMatrix(self, matrix):
        # write code here
        res = []
        if len(matrix)==0 or len(matrix[0])==0:
            return res
        m, n = len(matrix), len(matrix[0])
        j = 0
        while len(res)<m*n:
            res.extend(matrix[j][j:n-j])
            for i in range(j+1, m-j):
                res.append(matrix[i][n-j-1])
            res.extend(matrix[m-j-1][j:n-j-1][::-1])
            for i in range(m-j-2, j, -1):
                res.append(matrix[i][j])
            j +=1
        return res[0:m*n]
```

### 11.栈的压入和弹出

题目描述

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

```python
# -*- coding:utf-8 -*-
class Solution:
    def IsPopOrder(self, pushV, popV):
        # write code here
        if len(pushV)==0 or len(popV)==0:
            return False
        stack = []
        for v in pushV:
            stack.append(v)
            while stack and stack[-1]==popV[0]:
                stack.pop()
                popV.pop(0)
        return len(stack)==0
```

### 12.输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。

```python
# -*- coding:utf-8 -*-
class Solution:
    def VerifySquenceOfBST(self, sequence):
        # write code here
        if len(sequence)==0:
            return False
        index = 0   # 用于记录左右子树的分节点
        for i in range(len(sequence)):
            if sequence[i]>sequence[-1]:
                index = i
                break
        for j in range(i, len(sequence)):
            if sequence[j]<sequence[-1]:
                return False
        left = True
        right = True
        if len(sequence[:index])>0:
            left = self.VerifySquenceOfBST(sequence[:index])
        if len(sequence[index:-1])>0:
            right = self.VerifySquenceOfBST(sequence[index:-1])
        return left and right
```

### 13.Posting List(复杂链表)，有两个指针，next和random

```python
class RandomListNode:
    def __init__(self, x):
        self.label = x
        self.next = None
        self.random = None
class Solution:
    # 返回 RandomListNode
    def __init__(self):
        self.cpHead = None
        self.head = None
    def Clone(self, pHead):
        # write code here
        if pHead is None:
            return pHead
        self.head = pHead
        self.copyNode()
        self.copyRandomNode()
        self.resumList()
        return self.cpHead
	# 第一步复制节点， 改变next指针
    def copyNode(self):    
        ptr = self.head
        while ptr:
            cpNode = RandomListNode(ptr.label)
            cpNode.next = ptr.next
            ptr.next = cpNode
            ptr = cpNode.next
        self.cpHead = self.head.next
	# 复制随机指针
    def copyRandomNode(self):
        ptr = self.head
        while ptr:
            randomNode = ptr.random
            cpNode = ptr.next
            if randomNode:
                cpNode.random = randomNode.next
            ptr = cpNode.next
	# 恢复原来的链表
    def resumList(self):
        ptr = self.head
        while ptr:
            cpNode = ptr.next
            ptr.next = cpNode.next
            if ptr.next:
                cpNode.next = ptr.next.next
            else:
                cpNode.next = None
            ptr = ptr.next
```

### 14.对称的二叉树

```python
class Solution:
    def isSymmetrical(self, pRoot):
        # write code here
        if pRoot==None:
            return True
        result = self.isEqual(pRoot.left, pRoot.right)
        return result

    def isEqual(self, root1, root2):
        if not root1 and not root2:
            return True
        elif root1 and not root2:
            return False
        elif root2 and not root1:
            return False
        if root1.val!=root2.val:
            return False
        left = self.isEqual(root1.left, root2.right)
        right = self.isEqual(root1.right, root2.left)
        return left and right
```

### 15.二叉树中和为某一值得路径

**解题思路：**

我们可以先从最简单的情况开始考虑，最简单的情况就是二叉树只有一个根节点，判断根节点的值与期望值是否相同就ok了。二叉树稍微复杂一点就是根节点还有左右子节点，这时候的过程就要多一步，仍旧是先判断根节点的值与期望值，如果相等或者期望值更小，则不必继续向下判断，如果期望值更大，那么可以向下继续判断，此时的期望值变成了“期望值-根节点的值”，用新的期望值分别与左右子节点的值进行比较，因为左右子节点已经是叶节点，符合路径的定义，因此如果节点的值与新的期望值相等，就得到了答案，如果不相等，问题无解。现在推广到普通的二叉树，与上面的分析相同，就是一个不断更新期望值并与节点值比较的过程，这个过程是重复的，可以利用递归完成，

**代码实现**

```python
class Solution:
    # 返回二维列表，内部每个列表表示找到的路径
    def FindPath(self, root, expectNumber):
        # write code here
        res = []
        if root is None:
            return res
        def iterPath(root, expectNumber, dic):
            if expectNumber>root.val:
                dic.append(root.val)
                if root.left:
                    iterPath(root.left, expectNumber-root.val, dic)
                if root.right:
                    iterPath(root.right, expectNumber - root.val, dic)
            elif expectNumber==root.val:
                dic.append(root.val)
                if not root.left and not root.right:
                    res.append(dic[:])
            else:
                dic.append(0)
            dic.pop()    # pop操作的目的就是让dic从当前节点重新回到其父亲节点
        iterPath(root, expectNumber, [])
        return res
```

### 16.二叉搜索树和双向链表

按中序遍历二叉树，每遍历一个节点，更新整个双向链表的头指针和尾指针。

```python
class Solution:
    def __init__(self):
        self.Listhead = None
        self.ListTail = None
    def Convert(self, pRootOfTree):
        if pRootOfTree is None:
            return 
        self.Convert(pRootOfTree.left)
        if self.Listhead is None:
            self.Listhead = pRootOfTree
            self.ListTail = pRootOfTree
        else:
            self.ListTail.right = pRootOfTree
            pRootOfTree.left = self.ListTail
            self.ListTail = pRootOfTree
        self.Convert(pRootOfTree.right)
        return self.Listhead
```

### 17.字符串排列

例如：abc, 得到的结果为： abc,acb,bac,bca,cab,cba

```python
# -*- coding:utf-8 -*-
class Solution:
    def Permutation(self, ss):
        # write code here
        def solve(ss, soultion):
            if len(ss)==0:
                if soultion not in res:
                    res.append(soultion)
                return
            for i in range(len(ss)):
                newSolution = soultion + ss[i]
                new_ss = ss[0:i]+ss[i+1:]
                solve(new_ss, newSolution)
        res = []
        if len(ss)==0:
            return res
        solve(ss, '')
        return res
```

### 18.整数1中出现的次数

题目描述

求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。

```python
class Solution:
    def NumberOf1Between1AndN_Solution(self, n):
        # write code here
        if n<1:
            return 0
        count = 0
        base = 1
        round = n
        while round>0 :
            weight = round%10
            round /= 10
            count += round*base
            if weight==1:
                count+=(n%base)+1
            elif weight>1:
                count += base
            base*=10
        return count
```

### 19.把数组排列成最小的数

题目描述

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

```python
# -*- coding:utf-8 -*-
import sys
class Solution:
    def PrintMinNumber(self, numbers):
        # write code here
        if len(numbers)==0:
            return ''
        res = sys.maxsize
        res = self.getMin(numbers,'',res)
        return int(res)

    def getMin(self, numbers, solution, res):
        if len(numbers) == 0:
            if 1 <= int(solution) <= sys.maxsize:
                res = min(res, int(solution))
                return res
            else:
                return res
        for i in range(len(numbers)):
            newSolution = solution + str(numbers[i])
            newNumbers = numbers[0:i]+numbers[i+1:]
            res = self.getMin(newNumbers, newSolution, res)
        return res
```

### 20.统计一个数字在排序数组中出现的次数。

因为data中都是整数，所以可以稍微变一下，不是搜索k的两个位置，而是搜索k-0.5和k+0.5这两个数应该插入的位置，然后相减即可。

```python
# -*- coding:utf-8 -*-
class Solution:
    def GetNumberOfK(self, data, k):
        # write code here
        count = 0
        if len(data)==0:
            return count
        def insert(data, num):
            i, j = 0, len(data)-1
            while i<=j:
                m = i + (j - i) // 2
                if data[m] < num:
                    i = m + 1
                elif data[m]>num:
                    j = m - 1
            return i
        i = insert(data, k-0.5)
        j = insert(data, k+0.5)
        return j - i
```

### 21.判断二叉树的平衡性

解题思路

比较每个节点的左子树和右子树的高度差，如果绝对值大于1，则表明该二叉树不平衡

```python
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def __init__(self):
        self.balance = True
    def IsBalanced_Solution(self, pRoot):
        # write code here
        self.computeBlance(pRoot)
        return self.balance

    def computeBlance(self,root):
        if root is None:
            return 0
        left = self.computeBlance(root.left)
        right = self.computeBlance(root.right)
        if abs(left - right) > 1:
            self.balance = False
        return max(left, right) + 1
```

### 22.和为S的连续正数序列

题目描述

小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!

```python
# -*- coding:utf-8 -*-
class Solution:
    def FindContinuousSequence(self, tsum):
        # write code here
        result = []
        plow, phigh = 1, 2
        while plow<phigh:
            cur = int((phigh + plow)*(phigh - plow + 1) / 2)
            if cur == tsum:
                result.append(list(range(plow,phigh+1)))
                plow += 1
            elif cur < tsum:
                phigh += 1
            else:
                plow += 1
        return result
```

### 23.和为S的两个数字

题目描述

输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。

```python
# -*- coding:utf-8 -*-
import sys
class Solution:
    def FindNumbersWithSum(self, array, tsum):
        # write code herea
        result = []
        minMultiply = sys.maxsize
        if len(array)==0:
            return result
        i, j = 0, len(array) - 1
        while i < j:
            tmp = array[i] + array[j]
            if tmp == tsum:
                tmpMultiply = array[i] * array[j]
                if tmpMultiply < minMultiply:
                    result = []
                    minMultiply = tmpMultiply
                    result.extend([array[i], array[j]])
                i += 1
                j -= 1
                while i < j and array[i] == array[i - 1]:
                    j += 1
                while i < j and array[j] == array[j + 1]:
                    j -= 1
            elif tmp < tsum:
                i += 1
            else:
                j -= 1
        return result
```

### 24.圆圈中剩下的数

题目描述

每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)

```python
# -*- coding:utf-8 -*-
class Solution:
    def LastRemaining_Solution(self, n, m):
        # write code here
        if n==0 or m==0:
            return -1
        queue = list(range(0,n))
        while len(queue)>1:
            No = m % len(queue) - 1
            if No==-1:
                queue = queue[0:No]
            else:
                queue = queue[No + 1:] + queue[0:No]
        return queue[0]
```

### 25.求1+2+3+...+4的和

题目描述

求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

解析：使用递归完成

```python
# -*- coding:utf-8 -*-
class Solution:
    def Sum_Solution(self, n):
        # write code here
        re = self.getSum(0,n)
        return re
    def getSum(self, result, n):
        if n > 0:
            result += n
            result = self.getSum(result, n - 1)
        return result
```

### 26.不用加减乘除做加法（不懂）

**题目描述**

写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。

```python
# -*- coding:utf-8 -*-
class Solution:
    def Add(self, num1, num2):
        # write code here
        while num2!=0:
            tmp = num1 ^ num2
            num2 = (num1 & num2) << 1
            num1 = tmp & 0xFFFFFFFF
        return num1 if num1 <= 0x7FFFFFFF else ~(num1 ^ 0xFFFFFFFF)
```

### 27.扑克牌顺子

题目描述

LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)...他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。

```python
# -*- coding:utf-8 -*-
class Solution:
    def IsContinuous(self, numbers):
        # write code here
        len_numbers = len(numbers)
        if len_numbers==0:
            return False
        numbers.sort()
        num_0 = [i for i in numbers if i==0]
        tmp_num = numbers[len(num_0):]
        # 判断除0之外的数字有没有重复的
        if len(tmp_num)!=len(set(tmp_num)):
            return False
        # 判断非0数字列表的长度为0时
        if len(tmp_num)==0:
            return True
        # 判断0的列表为空
        elif len(num_0)==0:
            return (tmp_num[-1]-len(tmp_num)+1)==tmp_num[0]
        else:
            # 需要0的数目
            need_num = (tmp_num[-1]-tmp_num[0]+1) - len(tmp_num)
            return need_num <= len(num_0)
```

### 28.把字符串转成整数

题目描述

将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。

输入描述:

```
输入一个字符串,包括数字字母符号,可以为空
```

输出描述:

```
如果是合法的数值表达则返回该数字，否则返回0
```

```python
# -*- coding:utf-8 -*-
class Solution:
    def StrToInt(self, s):
        # write code here
        re = 0
        if len(s)==0:
            return re
        flage = 1   # 正数和负数的标志
        if s[0]=='-':
            flage = -1
        s = s.lstrip('+')
        s = s.lstrip('-')
        carry = 1
        i = len(s)-1
        while i>=0:
            if '0'<=s[i]<='9':
                re += carry * int(s[i])
                carry = carry * 10
            else:
                return 0
            i -= 1
        return re * flage
```

### 29.正则表达式匹配

题目描述

请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配

```python
# -*- coding:utf-8 -*-
class Solution:
    # s, pattern都是字符串
    def match(self, s, pattern):
        # write code here
        # 判断匹配规则是否为空
        if pattern == "":
            # p为空的时候，判断s是否为空，则知道返回True 或 False
            return s == ""
        # 判断匹配规则是否只有一个
        if len(pattern) == 1:
            # 判断匹配字符串长度是否为1，和两者的第一个元素是否相同，或匹配规则使用.
            return len(s) == 1 and (s[0] == pattern[0] or pattern[0] == '.')
        # 匹配规则的第二个字符串不为*，当匹配字符串不为空的时候
        # 返回 两者的第一个元素是否相同，或匹配规则使用. and 递归新的字符串(去掉第一个字符的匹配字符串 和 去掉第一个字符的匹配规则)
        if pattern[1] != "*":
            if s == "":
                return False
            return (s[0] == pattern[0] or pattern[0] == '.') and self.match(s[1:], pattern[1:])
        # 当匹配字符串不为空 and (两者的第一个元素是否相同 or 匹配规则使用.)
        while s and (s[0] == pattern[0] or pattern[0] == '.'):
            # 到了while循环，说明p[1]为*，所以递归调用匹配s和p[2:](*号之后的匹配规则)
            # 用于跳出函数，当s循环到和*不匹配的时候，则开始去匹配p[2:]之后的规则
            if self.match(s, pattern[2:]):
                return True
            # 当匹配字符串和匹配规则*都能匹配的时候，去掉第一个字符成为新的匹配字符串，循环
            s = s[1:]
        # 假如第一个字符和匹配规则不匹配，则去判断之后的是否匹配
        return self.match(s, pattern[2:])
```

### 30.表示数值的字符串

```python
class Solution:
    # s字符串
    def isNumeric(self, s):
        # write code here
        if s[0]=="+" or s[0]=="-":
            if s[1]!="+" and s[1]!="-":
                try:
                    if float(s[1:]):
                        return True
                except:
                    return False
            else:
                return False
        else:
            try:
                if float(s):
                    return True
            except:
                return False
```

### 31.字符流中第一个不重复的字符

题目描述

请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。

输出描述:

如果当前字符流没有存在出现一次的字符，返回#字符。

```python
# -*- coding:utf-8 -*-
class Solution:
    # 返回对应char
    def __init__(self):
        self.res = ''
        self.stack = []
        self.first = '#'
    def FirstAppearingOnce(self):
        # write code here
        return self.first

    def Insert(self, char):
        # write code here
        if char not in self.stack:
            self.stack.append(char)
            if self.first=='#':
                self.first = char
        else:
            if char==self.first:
                self.stack.remove(char)
                self.first = self.stack[0] if len(self.stack)>0 else '#'
            else:
                self.stack.remove(char)
```

### 32.删除链表中重复的元素

```python
# -*- coding:utf-8 -*-
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
class Solution:
    def deleteDuplication(self, pHead):
        # write code here
        if pHead is None or pHead.next is None:
            return pHead
        pre, ptr, dis = pHead, pHead.next, None
        while ptr:
            if pre.val == ptr.val:
                s, e = pre, ptr.next
                while e and e.val ==s.val:
                    e = e.next
                if dis is None:
                    pHead = e
                else:
                    dis.next = e
                ptr = e    # 此时e 可能为空
            else:
                dis = pre
            if ptr:  #判断ptr是否为空
                pre, ptr = ptr, ptr.next
        return pHead
```

### 33.二叉树的下一个节点

解题思路：

```
IF   该节点为单个节点，即没有父节点、左节点、右节点
		return  None
ELIF  该节点为叶子节点：
      IF 该节点为左叶子节点
         return 该节点的父节点
      IF 该节点为右叶子节点
         IF 该节点为左子树的叶节点：
            return 根节点
         IF 该节点为右字数的叶节点：
            return None
Else
     找到右子树的最深的第一个左节点
```



```python
class Solution:
    def GetNext(self, pNode):
        if(pNode.next is None and pNode.left is None and pNode.right is None):
            # 只有一个节点
            return None
        elif pNode.left is None and pNode.right is None:
            # 该节点为叶子节点时
            fatherNode = pNode.next
            if fatherNode.left==pNode:
                # 为左叶节点
                return pNode.next
            if fatherNode.right == pNode:
                # 为右叶节点
                ptr = fatherNode
                while ptr.next:
                    ptr = ptr.next
                return ptr if ptr.right.val > pNode.val else None
        else:
            if pNode.right is None:
                return pNode.next
            else:
                ptr = pNode.right
                while ptr and ptr.left:
                    ptr = ptr.left
                return ptr
```

### 34.序列化二叉树

```python
class Solution:
    def Serialize(self, root):
        # write code here
        res = []
        if root is None:
            return res
        queue = [root]
        while len(queue)>0:
            next_queue = []
            for node in queue:
                if node == '#':
                    res.append('#')
                else:
                    res.append(node.val)
                    if node.left and node.right:
                        next_queue.append(node.left)
                        next_queue.append(node.right)
                    elif node.left and not node.right:
                        next_queue.append(node.left)
                        next_queue.append('#')
                    elif not node.left and node.right:
                        next_queue.append('#')
                        next_queue.append(node.right)
            queue = next_queue[:]
        return res

    def Deserialize(self, s):
        # write code here
        if len(s)==0:
            return None
        if len(s)==1:
            return TreeNode(s[0])
        nodeList = s
        head = TreeNode(nodeList.pop(0))
        rootLayer = [head]

        while len(nodeList) > 0:
            newRootLayer = []
            nodeLayer = nodeList[0:2*len(rootLayer)]
            for root in rootLayer:
                if len(nodeLayer)>0:
                    leftNode = nodeLayer.pop(0)
                    rightNode = nodeLayer.pop(0) if len(nodeLayer)>0 else '#'
                    if leftNode != '#':
                        root.left = TreeNode(int(leftNode))
                        newRootLayer.append(root.left)
                    if rightNode != '#':
                        root.right = TreeNode(int(rightNode))
                        newRootLayer.append(root.right)
            nodeList = nodeList[2 * len(rootLayer):]
            rootLayer = newRootLayer[:]
        return head
```

### 35.在字符串形式的矩阵中查找字符串

题目描述

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。

```python
# -*- coding:utf-8 -*-
class Solution:
    def hasPath(self, matrix, rows, cols, path):
        # write code here
        if rows==0 or cols==0:
            return False
        dp = []
        while len(matrix)!=0:
            dp.append(list(matrix[0:cols]))
            matrix = matrix[cols:]
        for i in range(rows):
            for j in range(cols):
                if self.helper(dp, i, j, path):
                    return True
        return False

    def helper(self,matrix, i, j, path):
        if len(path)==0:
            return True
        if 0<=i<len(matrix) and 0<=j<len(matrix[0]):
            if matrix[i][j]==path[0]:
                matrix[i][j] = ''
                if self.helper(matrix, i-1, j, path[1:]):
                    return True
                if self.helper(matrix, i+1, j, path[1:]):
                    return True
                if self.helper(matrix, i, j-1, path[1:]):
                    return True
                if self.helper(matrix, i, j+1, path[1:]):
                    return True
                matrix[i][j] = path[0]
        return False
```

### 36.机器人的运动范围

```python
# -*- coding:utf-8 -*-
class Solution:
    def movingCount(self, threshold, rows, cols):
        # write code here
        if rows<1 or cols<1 or threshold <0:
            return 0
        dp = [[0 for _ in range(cols)] for _ in range(rows)]
        count = 0
        #判断第一行
        for j in range(cols):
            if self.every(0) + self.every(j) <= threshold:
                dp[0][j] = 1
                count += 1
            else:
                break
        #判断第一列
        for i in range(rows):
            if self.every(i) + self.every(0) <= threshold:
                dp[i][0] = 1
                count += 1
            else:
                break
        # 判断其他的位置
        for i in range(1, rows):
            for j in range(1, cols):
                if self.every(i) + self.every(j) <= threshold:
                    if dp[i-1][j]!=0 or dp[i][j-1]!=0:  #可到达此位置的条件
                        dp[i][j] = 1
                        count += 1
        return count-1   # 0,0位置多加了一遍

    def every(self,x):  # 计算一个数的各个未的和
        result = 0
        while x!=0:
            result += x % 10
            x  = x // 10
        return result
```



# 腾讯2019秋招笔试真题

### 1.小Q爬塔

**题目描述：**

一共有n层塔，每两层的净高度都不一样。如果每层塔的高度为x，则爬过该层塔需要的时间也为x。小Q可使用魔法跳跃一层或者两层，但是每次跳跃后就将魔法用完了，必须至少爬过一层才可以再次跳跃，问小Q爬到最高层最短需要多少时间。

**解题思路：**

使用数组p来表示爬到该层塔，使用t来表跳到该层塔，用i来表示该层塔。

```
情况1：到达第i层是爬，那么到达第i-1层可以是爬或者跳
p[i]  =   min(p[i-1],  t[i-1])  +  a[i]
情况2：到达第i层是跳，那么可以从i-1层跳，也可以从i-2层跳
t[i]   =   min(p[i-1],  p[i-2])
```

```python
class Solution:
    def minTime(self, n, a):
        if n<2:
            return 0
        p = [0] * n
        t = [0] * n
        p[0], p[1] = a[0], a[1]
        for i in range(2,n):
            p[i] = min(p[i-1], t[i-1]) + a[i]
            t[i] = min(p[i-1], p[i-2])
        return min(p[-1], t[-1])

print(Solution().minTime(5, [3,5,1,8,4]))
```



### 2.得到黑格和白格的数目

**题目描述：**

一张棋谱，有n行m列，（1,1）位置为白格，相邻的格的颜色不一样。现在选定一个左下标为（x0, y0）的格子，再选定右上标为（x1,y1），将该区域的格子涂成白色。然后再次选定左下标（x2,y2），右上标为（x3,y3）的区域，将该区域的格子涂成黑色，求最后白色格子和黑色格子各有多少个？

**解题思路：**

例如3*3的棋盘的布局如下图所示

| **白格（1，1）** | **黑格（1,2）** | **白格（1,3）** |
| ---------------- | --------------- | --------------- |
| **黑格（2,1）**  | **白格（2,2）** | **黑格（2,3）** |
| **白格（3，1）** | **黑格（3,2）** | **白格（3,3）** |

```python
class Solution:
    def whiltAndBlack(self,n,m,x0,y0,x1,y1,x2,y2,x3,y3):
        if n<1 or m<1:
            return [0,0]
        black = n * m // 2   # 黑色方格的数目
        white = n * m - black   # 白色方格的数目
        '''
        第一步将(x0, y0), (x1, y1)矩形内的方块都涂白，计算出黑方块的个数d，
        '''
        # 如果起始位置是黑色方格(和为奇数)
        if (x0 + y0) & 1 :
            # 如果矩形中方格的数目是奇数，则黑色方格多一个
            d = ((x1-x0+1)*(y1-y0+1)+1) // 2
        # 如果起始位置是白色方格(和为偶数)
        else:
            d = (x1-x0+1)*(y1-y0+1)//2
        white += d
        black -= d
        '''
        第二步将(x2, y2), (x3, y3)矩形内的方块都涂黑，计算出白方块的个数d，
        '''
        #如果起始位置是黑色方格(和为奇数)
        if (x2+y2)&1:
            d = (x3-x2+1)*(y3-y2+1) //2
        # 如果起始位置是白色方格(和为偶数)
        else:
            # 如果矩形中方格的数目是奇数，则白色方格多一个
            d = ((x3-x2+1)*(y3-y2+1)+1)//2
        black += d
        white -= d
        '''
        第三步，找到两个矩形的公共部分。计算第一步将黑方格涂成白方格的数目，即计算黑方格的数目e
        '''
        a, b, c, d = max(x0, x2), max(y0, y2), min(x1, x3), min(y1, y3)
        # 没有相交区域
        if c < a or d < b:  
            e = 0
        else:
            if (a + b) & 1:
                e = ((c-a+1)*(d-b+1)+1) // 2
            else:
                e = (c-a+1)*(d-b+1) //2
        white -= e
        black += e
        return [white, black]

print(Solution().whiltAndBlack(1,3,1,1,1,3,1,1,1,3))
print(Solution().whiltAndBlack(3,3,1,1,2,3,2,1,3,3))
print(Solution().whiltAndBlack(3,4,2,1,2,4,1,2,3,3))
```

### 3.小Q的最小值序列

**题目描述：**

小Q得到了一个长度为n的序列A，A中的数各不相同。对于A中的每一个数Ai，求：
min(1 <= j < i)|Ai - Aj|，令这个式子取到的最小值的j记为Pi，若最小值不唯一，则选择使Aj较小的那个。

**解决思路：**

使用暴力法。

```python
class Solution:
    def getMinAbs(self, n, A):
        pi = None
        for i in range(1, n):
            minAbs = 10 ** 9
            for j in range(0,i):
                if abs(A[i]-A[j]) < minAbs:
                    minAbs = abs(A[i]-A[j])
                    pi = j + 1
                elif abs(A[i]-A[j]) == minAbs:
                    if A[j] < A[pi-1]:
                        pi = j + 1
            print('{0} {1}'.format(minAbs, pi))

Solution().getMinAbs(4, [1,5,3,4])
```

### 4.求到达n-1个点的最短距离

**题目描述：**

在一场比赛中有n个检查点，比赛要求到达n-1个检查点即可，这些检查点排列在x轴上，位置分别为x1，x2，...，xn，且允许以任意顺序访问检查点。比赛的开始位置为a，求完成比赛所经过的最小距离。
【输入描述：】 输入包含两行 第一行为两个参数n，a，其中1 <= n <= 100000, -1000000 <= a <= 1000000 第二行为n个整数：x1,x2,...,xn(-1000000 <= xn <= 1000000)

**解题思路：**

```
【输出描述】 输出一个整数
输入：
3 10
1 7 12
输出：
7
```

```python
import sys
class Solution:
    def getMinValur(self, l1, l2):
        n, a = l1[0], l1[1]   # 站点的个数
        point = l2[:]
        if n<=1:
            return 0
        if a<point[0]:
            re = point[-2] - a
        elif a > point[n-1]:
            re = a - point[1]
        else:
            left = a-point[0]
            right = point[-1] - a
            if left > right:
                re = min(right, a - point[1]) + (point[-1] - point[1])
            else:
                re = min(left, point[-2] - a) + (point[-2] - point[0])
        return re

if __name__ == '__main__':
    test1 = {'l1': [3, 10], 'l2': [1, 7, 12], 'result': 7}
    test2 = {'l1': [3, 14], 'l2': [1, 7, 12], 'result': 7}
    test3 = {'l1': [3, 0], 'l2': [1, 7, 12], 'result': 7}
    test = [test1, test2, test3]
    for t in test:
        re = Solution().getMinValur(t['l1'], t['l2'])
        print(re==t['result'])
```



### 5.获取扔掉牌的编号

**题目描述**

小Q有一叠纸牌，一共有n张，从上往下依次编号为1~n。现在小Q要进行以下重复操作：把位于顶端的牌扔掉，把新的顶端的牌放到这叠牌的底部。小Q会一直操作到只剩下一张牌为止，小Q想知道每次扔掉的牌的编号。
【输入描述】
一个数字n， 1 <= n <= 1000000

【输出描述】
n个空格间隔的整数，表示每次丢掉的纸牌编号

```
输入：
7

输出：
## 1 3 5 7 4 2 6
```

```python
class Solution:
    def getSequence(self, n):
        res = []
        if n<1:
            return res
        dp = list(range(1, n+1))
        while len(dp)>1:
            res.append(dp.pop(0))
            dp = dp[1:]+[dp[0]]
        return res

print(Solution().getSequence(n=7))
```



# 字节跳动

### 1.选出数组中的一个区间，使得数组中的最小值乘以该数组的和最大

```python
# _*_ coding:utf-8 _*_
import sys
while True:
    try:
        n = int(sys.stdin.readline().strip())
        line = sys.stdin.readline().strip().split(' ')
        arr = [int(i) for i in line]
        arr.append(-1)
        i = 0
        stack_pop_before = []
        stack = []
        ans = 0
        while i <= n:
            num = arr[i]
            pop_sum = 0
            pop_before = 0
            while stack and num < stack[-1]:
                pop_num = stack.pop()
                pop_sum += pop_num
                pop_before += stack_pop_before.pop()
                ans = max(ans, (pop_before + pop_sum) * pop_num)
            stack_pop_before.append(pop_before + pop_sum)
            stack.append(num)
            i += 1
        print(ans)
    except :

        break

```

